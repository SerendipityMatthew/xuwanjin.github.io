<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title> 装饰者模式 Wrapper/Decorator Pattern | Gridea</title>
<link rel="shortcut icon" href="http://xuwanjin.me//favicon.ico?v=1568370973440">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://xuwanjin.me//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://xuwanjin.me/">
  <img class="avatar" src="http://xuwanjin.me//images/avatar.png?v=1568370973440" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
               装饰者模式 Wrapper/Decorator Pattern
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-07-27 ·
              </time>
              
                <a href="http://xuwanjin.me//tag/aYO9_UESq" class="post-tag">
                  # 装饰者模式
                </a>
              
                <a href="http://xuwanjin.me//tag/DYemqMTK7" class="post-tag">
                  # 设计模式
                </a>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('http://xuwanjin.me//post-images/zhuang-shi-zhe-mo-shi-wrapperdecorator-pattern.png')">
              </div>
            
            <div class="post-content">
              <p>个人理解装饰者模式的</p>
<!-- more -->
<h1 id="装饰者模式-wrapperdecorator-pattern">装饰者模式 Wrapper/Decorator Pattern</h1>
<p>@(design pattern)</p>
<h2 id="具体例子">具体例子</h2>
<p>首先我们看看 AOSP 的中装饰者模式,</p>
<h3 id="contextwrapper-例子">ContextWrapper 例子</h3>
<pre><code>// frameworks/base/core/java/android/content/ContextWrapper.java
public class ContextWrapper extends Context {
    Context mBase;

    public ContextWrapper(Context base) {
        mBase = base;
    }
    
    /**
     * Set the base context for this ContextWrapper.  All calls will then be
     * delegated to the base context.  Throws
     * IllegalStateException if a base context has already been set.
     * 
     * @param base The new base context for this wrapper.
     */
    protected void attachBaseContext(Context base) {
        if (mBase != null) {
            throw new IllegalStateException(&quot;Base context already set&quot;);
        }
        mBase = base;
    }
        /**
     * @return the base context as set by the constructor or setBaseContext
     */
    public Context getBaseContext() {
        return mBase;
    }

    @Override
    public AssetManager getAssets() {
        return mBase.getAssets();
    }

    @Override
    public Resources getResources() {
        return mBase.getResources();
    }

    @Override
    public PackageManager getPackageManager() {
        return mBase.getPackageManager();
    }

    @Override
    public ContentResolver getContentResolver() {
        return mBase.getContentResolver();
    }

    @Override
    public Looper getMainLooper() {
        return mBase.getMainLooper();
    }
     // 省略掉其他的方法
    /**
     * @hide
     */
    @TestApi
    @Override
    public void setAutofillCompatibilityEnabled(boolean  autofillCompatEnabled) {
        if (mBase != null) {
            mBase.setAutofillCompatibilityEnabled(autofillCompatEnabled);
        }
    }
}

</code></pre>
<h3 id="iinputmethodsessionwrapper-例子">IInputMethodSessionWrapper 例子</h3>
<pre><code>// frameworks/base/core/java/android/inputmethodservice/IInputMethodSessionWrapper.java
class IInputMethodSessionWrapper extends IInputMethodSession.Stub
        implements HandlerCaller.Callback {
    private static final String TAG = &quot;InputMethodWrapper&quot;;
    
    private static final int DO_FINISH_INPUT = 60;
    private static final int DO_DISPLAY_COMPLETIONS = 65;
    private static final int DO_UPDATE_EXTRACTED_TEXT = 67;
    private static final int DO_UPDATE_SELECTION = 90;
    private static final int DO_UPDATE_CURSOR = 95;
    private static final int DO_UPDATE_CURSOR_ANCHOR_INFO = 99;
    private static final int DO_APP_PRIVATE_COMMAND = 100;
    private static final int DO_TOGGLE_SOFT_INPUT = 105;
    private static final int DO_FINISH_SESSION = 110;
    private static final int DO_VIEW_CLICKED = 115;

    HandlerCaller mCaller;
    InputMethodSession mInputMethodSession;
    InputChannel mChannel;
    ImeInputEventReceiver mReceiver;

    public IInputMethodSessionWrapper(Context context,
            InputMethodSession inputMethodSession, InputChannel channel) {
        mCaller = new HandlerCaller(context, null,
                this, true /*asyncHandler*/);
        mInputMethodSession = inputMethodSession;
        mChannel = channel;
        if (channel != null) {
            mReceiver = new ImeInputEventReceiver(channel, context.getMainLooper());
        }
    }

    public InputMethodSession getInternalInputMethodSession() {
        return mInputMethodSession;
    }
     @Override
    public void executeMessage(Message msg) {
        if (mInputMethodSession == null) {
            // The session has been finished. Args needs to be recycled
            // for cases below.
            switch (msg.what) {
                case DO_UPDATE_SELECTION:
                case DO_APP_PRIVATE_COMMAND: {
                    SomeArgs args = (SomeArgs)msg.obj;
                    args.recycle();
                }
            }
            return;
        }

        switch (msg.what) {
            case DO_FINISH_INPUT:
                mInputMethodSession.finishInput();
                return;
            case DO_DISPLAY_COMPLETIONS:
                mInputMethodSession.displayCompletions((CompletionInfo[])msg.obj);
                return;
            case DO_UPDATE_EXTRACTED_TEXT:
                mInputMethodSession.updateExtractedText(msg.arg1,
                        (ExtractedText)msg.obj);
                return;
            case DO_UPDATE_SELECTION: {
                SomeArgs args = (SomeArgs)msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2,
                        args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
            case DO_UPDATE_CURSOR: {
                mInputMethodSession.updateCursor((Rect)msg.obj);
                return;
            }
            case DO_UPDATE_CURSOR_ANCHOR_INFO: {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo)msg.obj);
                return;
            }
            case DO_APP_PRIVATE_COMMAND: {
                SomeArgs args = (SomeArgs)msg.obj;
                mInputMethodSession.appPrivateCommand((String)args.arg1,
                        (Bundle)args.arg2);
                args.recycle();
                return;
            }
            case DO_TOGGLE_SOFT_INPUT: {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
            case DO_FINISH_SESSION: {
                doFinishSession();
                return;
            }
            case DO_VIEW_CLICKED: {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
        }
        Log.w(TAG, &quot;Unhandled message code: &quot; + msg.what);
    }

    private void doFinishSession() {
        mInputMethodSession = null;
        if (mReceiver != null) {
            mReceiver.dispose();
            mReceiver = null;
        }
        if (mChannel != null) {
            mChannel.dispose();
            mChannel = null;
        }
    }

    @Override
    public void finishInput() {
        mCaller.executeOrSendMessage(mCaller.obtainMessage(DO_FINISH_INPUT));
    }

    @Override
    public void displayCompletions(CompletionInfo[] completions) {
        mCaller.executeOrSendMessage(mCaller.obtainMessageO(
                DO_DISPLAY_COMPLETIONS, completions));
    }

    @Override
    public void updateExtractedText(int token, ExtractedText text) {
        mCaller.executeOrSendMessage(mCaller.obtainMessageIO(
                DO_UPDATE_EXTRACTED_TEXT, token, text));
    }

    @Override
    public void updateSelection(int oldSelStart, int oldSelEnd,
            int newSelStart, int newSelEnd, int candidatesStart, int candidatesEnd) {
        mCaller.executeOrSendMessage(mCaller.obtainMessageIIIIII(DO_UPDATE_SELECTION,
                oldSelStart, oldSelEnd, newSelStart, newSelEnd,
                candidatesStart, candidatesEnd));
    }
}
</code></pre>
<h3 id="cursorwrapper-例子">CursorWrapper 例子</h3>
<pre><code>// frameworks/base/core/java/android/database/CursorWrapper.java
public class CursorWrapper implements Cursor {
    /** @hide */
    protected final Cursor mCursor;

    /**
     * Creates a cursor wrapper.
     * @param cursor The underlying cursor to wrap.
     */
    public CursorWrapper(Cursor cursor) {
        mCursor = cursor;
    }

    /**
     * Gets the underlying cursor that is wrapped by this instance.
     *
     * @return The wrapped cursor.
     */
    public Cursor getWrappedCursor() {
        return mCursor;
    }

    @Override
    public void close() {
        mCursor.close(); 
    }
 
    @Override
    public boolean isClosed() {
        return mCursor.isClosed();
    }

    @Override
    public int getCount() {
        return mCursor.getCount();
    }
        @Override
    public void unregisterContentObserver(ContentObserver observer) {
        mCursor.unregisterContentObserver(observer);
    }

    @Override
    public void unregisterDataSetObserver(DataSetObserver observer) {
        mCursor.unregisterDataSetObserver(observer);
    }
}
</code></pre>
<h3 id="inputconnectionwrapper-例子">InputConnectionWrapper 例子</h3>
<pre><code>// frameworks/base/core/java/android/view/inputmethod/InputConnectionWrapper.java
public class InputConnectionWrapper implements InputConnection {
    private InputConnection mTarget;
    final boolean mMutable;
    @InputConnectionInspector.MissingMethodFlags
    private int mMissingMethodFlags;

    /**
     * Initializes a wrapper.
     *
     * &lt;p&gt;&lt;b&gt;Caveat:&lt;/b&gt; Although the system can accept {@code (InputConnection) null} in some
     * places, you cannot emulate such a behavior by non-null {@link InputConnectionWrapper} that
     * has {@code null} in {@code target}.&lt;/p&gt;
     * @param target the {@link InputConnection} to be proxied.
     * @param mutable set {@code true} to protect this object from being reconfigured to target
     * another {@link InputConnection}.  Note that this is ignored while the target is {@code null}.
     */
    public InputConnectionWrapper(InputConnection target, boolean mutable) {
        mMutable = mutable;
        mTarget = target;
        mMissingMethodFlags = InputConnectionInspector.getMissingMethodFlags(target);
    }

    /**
     * Change the target of the input connection.
     *
     * &lt;p&gt;&lt;b&gt;Caveat:&lt;/b&gt; Although the system can accept {@code (InputConnection) null} in some
     * places, you cannot emulate such a behavior by non-null {@link InputConnectionWrapper} that
     * has {@code null} in {@code target}.&lt;/p&gt;
     * @param target the {@link InputConnection} to be proxied.
     * @throws SecurityException when this wrapper has non-null target and is immutable.
     */
    public void setTarget(InputConnection target) {
        if (mTarget != null &amp;&amp; !mMutable) {
            throw new SecurityException(&quot;not mutable&quot;);
        }
        mTarget = target;
        mMissingMethodFlags = InputConnectionInspector.getMissingMethodFlags(target);
    }

    /**
     * @hide
     */
    @InputConnectionInspector.MissingMethodFlags
    public int getMissingMethodFlags() {
        return mMissingMethodFlags;
    }

    /**
     * {@inheritDoc}
     * @throws NullPointerException if the target is {@code null}.
     */
    @Override
    public CharSequence getTextBeforeCursor(int n, int flags) {
        return mTarget.getTextBeforeCursor(n, flags);
    }
// 省略掉一部分方法
    /**
     * {@inheritDoc}
     * @throws NullPointerException if the target is {@code null}.
     */
    @Override
    public boolean commitContent(InputContentInfo inputContentInfo, int flags, Bundle opts) {
        return mTarget.commitContent(inputContentInfo, flags, opts);
    }
}

</code></pre>
<h3 id="observerresourcewrapper-例子">ObserverResourceWrapper 例子</h3>
<pre><code>// RxJava/src/main/java/io/reactivex/internal/operators/observable/ObserverResourceWrapper.java
public final class ObserverResourceWrapper&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable {

    private static final long serialVersionUID = -8612022020200669122L;

    final Observer&lt;? super T&gt; downstream;

    final AtomicReference&lt;Disposable&gt; upstream = new AtomicReference&lt;Disposable&gt;();

    public ObserverResourceWrapper(Observer&lt;? super T&gt; downstream) {
        this.downstream = downstream;
    }

    @Override
    public void onSubscribe(Disposable d) {
        if (DisposableHelper.setOnce(upstream, d)) {
            downstream.onSubscribe(this);
        }
    }

    @Override
    public void onNext(T t) {
        downstream.onNext(t);
    }

    @Override
    public void onError(Throwable t) {
        dispose();
        downstream.onError(t);
    }
}
</code></pre>
<h3 id="subscriberresourcewrapper-例子">SubscriberResourceWrapper 例子</h3>
<pre><code>// RxJava/src/main/java/io/reactivex/internal/subscribers/SubscriberResourceWrapper.java
public final class SubscriberResourceWrapper&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements FlowableSubscriber&lt;T&gt;, Disposable, Subscription {

    private static final long serialVersionUID = -8612022020200669122L;

    final Subscriber&lt;? super T&gt; downstream;

    final AtomicReference&lt;Subscription&gt; upstream = new AtomicReference&lt;Subscription&gt;();

    public SubscriberResourceWrapper(Subscriber&lt;? super T&gt; downstream) {
        this.downstream = downstream;
    }

    @Override
    public void onSubscribe(Subscription s) {
        if (SubscriptionHelper.setOnce(upstream, s)) {
            downstream.onSubscribe(this);
        }
    }

    @Override
    public void onNext(T t) {
        downstream.onNext(t);
    }

    @Override
    public void onError(Throwable t) {
        DisposableHelper.dispose(this);
        downstream.onError(t);
    }
 }

</code></pre>
<p>我们发现这些第一个例子里.</p>
<ol>
<li><code>ContextWrapper</code> 这个装饰者类里面, 他继承了 Context, 同事它的方法是几乎什么都没有干, 只是调用了 <code>mBase</code> 的相应的方法, 而 <code>mBase</code> 是什么呢, 他是 <code>Context</code> 类型的, <code>mBase</code> 在<code>ContextWrapper</code> 的构造器里和或者 <code>attachBaseContext</code> 方法实例化这个 <code>mBase</code>.  那 mBase 是什么类型了, 我们可以看看 attachBaseContext 方法在哪个地方调用了, 可以发现他在 Application 里面的 attach 方法里面调用了,
attach 方法又在 Instrumentation 类里面的 newApplication 调用, 再继续追踪在 LoadApk 里面的 makeApplication 方法里调用了该方法, 我们可以发现 Context 传入的是 ContextImpl 类型的.</li>
</ol>
<pre><code>   ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
   app = mActivityThread.mInstrumentation.newApplication(
           cl, appClass, appContext);
   appContext.setOuterContext(app);
</code></pre>
<p>那么 ContextImpl 是什么呢? 他是一个继承 Context 类型的类.
最终 Context, ContextWrapper, ContextImpl, ContextThemeWrapper, Activity 一起构成了一个 Wrapper 设计模式.</p>
<ol start="2">
<li><code>InputConnectionWrapper</code> 也是个装饰者类, 他实现了<code>InputConnection</code>, 在这类里面, 他的方法也是什么都没干的情况, 只是调用了InputConnection的实例 <code>mTarget</code> 的 方法. 同样 mTarget 只在<code>InputConnectionWrapper</code> 的构造函数里实例化.</li>
<li><code>IInputMethodSessionWrapper</code> 同样是一个装饰者类, 他继承了 <code>IInputMethodSession.Stub</code> , 实现了<code>HandlerCaller.Callback</code>.  这个装饰者类的方法也基本上什么都没干, 只是调用了 <code>Handler</code> 类型的<code>mCaller</code> 实例的 <code>executeOrSendMessage</code> 方法. 但是 mCaller 实际上还是调用了  mInputMethodSession , 的相应方法. mInputMethodSession 也是在 包装器的构造函数里. 同样我们可以追踪一下mInputMethodSession的来源. 在IInputMethodWrapper.InputMethodSessionCallbackWrapper的 sessionCreated 方法里传输了 Session 参数. 而这个方法被调用实在 AbstractInputMethodService.AbstractInputMethodImpl 的 createSession 方法里. 传输的参数是onCreateInputMethodSessionInterface 返回的对象. 可以发现最后是 InputMethodSessionImpl 类型的对象.
可以知道</li>
<li><code>CursorWrapper</code> 调用者的方法也是基本这样的.</li>
</ol>
<p>从上面的几个装饰者设计模式里面, 都可以发现类似这样的结构.</p>
<h3 id="定义">定义</h3>
<p>动态的给一个对象添加一些额外的职责, 就增加功能来说, 装饰模式相比生成子类更为灵活.</p>
<h3 id="结构">结构</h3>
<p>这里调用别人的图.
<img src="./decorator_pattern.png" alt="Alt text"></p>
<p>Component 是一个抽象构件. Component 是一个结构或者抽象类 就是定义我们的核心对象.
ConcreteComponent 是 Component 的实现. 需要需要装饰的就是它.
Decorator 一般是一个抽象类,  在他的属性里必然有一个 private 类型的 Component 类型的变量. 这个变量可以Decorator 的构造函数里赋值.
ConcreteDecorator 是继承于 Decorator 的具体实现装饰类.</p>
<h3 id="优点">优点</h3>
<ol>
<li>装饰模式是继承关系的一个替代方案,  否则会过长的继承树</li>
</ol>
<h3 id="缺点">缺点</h3>
<h3 id="使用场景">使用场景</h3>
<ol>
<li>动态的给一个对象增加功能, 这些功能可以在动态的撤销</li>
<li>需要扩展一个类的功能, 或者给一个类增加附加的功能</li>
<li>需要为一批的兄弟类进行改装和加装功能.</li>
</ol>
<h2 id="面试速回忆">面试速回忆</h2>
<h3 id="文字描述">文字描述</h3>
<ol>
<li>有两个类, 一个是包装器类 Wrapper, 一个是被包装的的类A, 他们同时继承于一个或者实现一个父类/接口 B. 包装器类持有一个B, 在包装器类的构造函数或者方法里调用的时候传入类 A. 然后 Wrapper 类的方法最终都是调用持有的字段的方法. 这样还可以用多个包装器类去继承同一个父类Wrapper.</li>
</ol>
<h3 id="具体案例">具体案例</h3>
<h2 id="参考文献">参考文献</h2>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://xuwanjin.me//post/mo-ban-fang-fa-she-ji-mo-shi-template-method">
              <h3 class="post-title">
                模板方法设计模式  Template Method
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="http://xuwanjin.me//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
