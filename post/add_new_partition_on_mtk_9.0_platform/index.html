<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MTK 9.0 平台添加一个分区 | Gridea</title>
<link rel="shortcut icon" href="http://xuwanjin.me//favicon.ico?v=1568420639414">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://xuwanjin.me//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://xuwanjin.me/">
  <img class="avatar" src="http://xuwanjin.me//images/avatar.png?v=1568420639414" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              MTK 9.0 平台添加一个分区
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-09-09 ·
              </time>
              
                <a href="http://xuwanjin.me//tag/Zg_yQZy12" class="post-tag">
                  # A/B
                </a>
              
                <a href="http://xuwanjin.me//tag/5lZE89ssD" class="post-tag">
                  # 分区
                </a>
              
                <a href="http://xuwanjin.me//tag/YawxDLvkG" class="post-tag">
                  # Android 9.0
                </a>
              
                <a href="http://xuwanjin.me//tag/kW4v0aZy6" class="post-tag">
                  # MTK
                </a>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('http://xuwanjin.me//post-images/add_new_partition_on_mtk_9.0_platform.png')">
              </div>
            
            <div class="post-content">
              <p>最近要在 MTK Android P 的平台, 添加一个 A/B 分区. 这其中踩了很多的坑. 以下是在添加新的分区当中遇到的问题进行的记录.</p>
<!-- more --> 
<h1 id="mtk-90-平台添加一个分区">MTK 9.0 平台添加一个分区</h1>
<p>最近要在 MTK Android P 的平台, 添加一个 A/B 分区. 这其中踩了很多的坑. 以下是在添加新的分区当中遇到的问题进行的记录.</p>
<p>##修改操作</p>
<p>添加一个AB分区, 并且添加相应的 image 文件
涉及到的文件. 已经设计的到的问题的总结:</p>
<pre><code>build/core/Makefile　　// ②　命令行之前需要有一个TAB, ⑧编译出现了failed with exit 4,  未知原因；　③导致生成的image文件出现错误； 　 ④生成了相关的image 但是没有放在　target_files_package下的　IMAGES　文件夹下
build/core/config.mk
build/core/config.mk
build/core/envsetup.mk
build/core/main.mk
build/tools/releasetools/add_img_to_target_files.py  // 　 ④add_img_to_target_files　出现无法找到相应的　image文件, 和makefile其中一个是同一个问题
build/tools/releasetools/build_image.py　　　
build/tools/releasetools/common.py

device/oemMa/project/partition_size.mk
device/mediatek/build/build/tools/ptgen/MT6761/partition_table_MT6761_emmc_ab.csv　①相关配置项的注意，Type，Download_File，Download，OTA_Update，FastBoot_Download, FastBoot_Erase，FastBoot_Erase
device/mediatek/common/device.mk
device/mediatek/mt6761/init.mt6761.rc 
device/mediatek/sepolicy/basic/non_plat/device.te
device/mediatek/sepolicy/basic/non_plat/non_plat/file.te
device/mediatek/sepolicy/basic/non_plat/non_plat/file_contexts // ⑧编译出现了failed with exit 4,  未知原因　&quot;/mnt/vendor/secos&quot; 还是 &quot;/secos&quot;
device/mediatek/sepolicy/basic/non_plat/non_plat/fsck.te
device/mediatek/sepolicy/basic/non_plat/non_plat/init.te
vendor/mediatek/proprietary/hardware/fstab/mt6765/fstab.in.mt6761　　　//⑤挂载参数错误导致的无法开机　⑧&quot;/mnt/vendor/secos&quot; 还是 &quot;/secos&quot;；　⑥修改参数之后开机没有挂载上去skipping, slotselect参数; ⑦无法挂载在根目录/
vendor/mediatek/proprietary/scripts/releasetools/mt_ota_preprocess.py
vendor/mediatek/proprietary/scripts/releasetools/replace_img_from_target_files.py
</code></pre>
<h3 id="修改分区表">修改分区表</h3>
<p>修改的分区表的内容, 其中分区的大小的单位是 KB,</p>
<pre><code>persist,EXT4,49152.0,,EMMC_USER,N,N,NONE,N,N,N,,N,,PROTECTED
antcommon,EXT4,102400,,EMMC_USER,N,Y,antcommon.img,N,N,N,,N,,AUTO
secos,EXT4,45120.0,,EMMC_USER,N,Y,secos.img,N,N,Y,,Y,,AUTO
sec1,Raw data,2048.0,,EMMC_USER,N,N,NONE,N,N,N,,N,,AUTO
proinfo,Raw data,3072.0,,EMMC_USER,N,N,NONE,N,N,N,,N,,PROTECTED
</code></pre>
<p>下面是对各个字段的说明:
Type，　　文件的分区格式　有Raw data 和 EXT4
Download_File， 刷机的时的文件的文件名称，比如system.img, 注意前面的文件和未前面的文件
Download，　　　　是否通过刷机的方式，应该和 Download_File 保持一致
OTA_Update，　　　是否通过OTA升级的方式升级该分区，如果加入的不是AB分区，建议写N
FastBoot_Download,  是否通过FastBoot的方式下载
EMMC  指的是内存的
MTK 的代码, 会根据 这个 CSV 文件, 生辰一个 Android_Scatter.txt 文件, 里面会包含分区的各种信息,
比如是否可以升级,1 刷机的文件名称, 其实的物理地址, 分区的大小, 分区的格式, 都是根据这个 csv 文件得来的.</p>
<h3 id="initrc-创建目录">init.rc 创建目录</h3>
<p>需要修改的 init.rc 文件.</p>
<pre><code>device/mediatek/mt6761/init.mt6761.rc
</code></pre>
<pre><code>
# Create CIP mount point
    mkdir /custom

    mkdir /mnt/cd-rom 0000 system system

    mkdir /mnt/vendor/secos 0777 root root

# change lk_env permission
    chown root system /proc/lk_env
    chmod 0660 /proc/lk_env
</code></pre>
<pre><code>    chown radio system /proc/freqhopping/dumpregs
    chown radio system /proc/freqhopping/freqhopping_debug
    chown radio system /proc/freqhopping/status
    chown radio system /proc/freqhopping/userdef
    chown system system /mnt/vendor/antcommon
    chmod 0777 /mnt/vendor/antcommon
    restorecon_recursive /mnt/vendor/antcommon
	# 改变路径的权限和用户以及用户组
    chown root root /mnt/vendor/secos
    chmod 0777 /mnt/vendor/secos
    restorecon_recursive /mnt/vendor/secos

# change owner
    chown system system /proc/bootprof
    chmod 0664 /proc/bootprof
    chown root system /proc/mtprof/cputime
    chown root system /proc/mtprof/reboot_pid

</code></pre>
<p>在这里, 我一开始想把这个分区挂载根目录下面, 也就是 /secos. 但是尝试了很多次, 都没有成功,</p>
<h3 id="挂载分区的-fstab-文件">挂载分区的 fstab 文件</h3>
<p>vendor/mediatek/proprietary/hardware/fstab/mt6765/fstab.in.mt6761</p>
<pre><code>DEVPATH(protect1)   /mnt/vendor/protect_f   ext4   FS_FLAG_COMMIT   FSMGR_FLAG_FMT
DEVPATH(protect2)   /mnt/vendor/protect_s   ext4   FS_FLAG_COMMIT   FSMGR_FLAG_FMT
DEVPATH(nvdata)     /mnt/vendor/nvdata      ext4   FS_FLAG_DISCARD  FSMGR_FLAG_FMT
DEVPATH(nvcfg)      /mnt/vendor/nvcfg       ext4   FS_FLAG_COMMIT   FSMGR_FLAG_FMT
DEVPATH(antcommon)  /mnt/vendor/antcommon   ext4   FS_FLAG_COMMIT   FSMGR_FLAG_FMT

DEVPATH(secos)      /mnt/vendor/secos   __MTK_DATAIMG_FSTYPE   defaults   FSMGR_FLAG_SYSTEM

#ifdef __PERSIST_PARTITION_SUPPORT
DEVPATH(persist)    /mnt/vendor/persist     ext4   FS_FLAG_COMMIT  FSMGR_FLAG_FMT
#endif

</code></pre>
<p>DEVPATH 是一个变量，关于路径的变量</p>
<pre><code>#define DEVPATH(_part) /dev/block/platform/BOOTDEV/by-name/_part
</code></pre>
<p>defaults　是一个默认的参数集
__MTK_DATAIMG_FSTYPE　在上面定义为 ext4 格式的</p>
<pre><code>#define FSMGR_FLAG_FMT  wait,check,formattable
</code></pre>
<h3 id="添加分区的-selinux-权限">添加分区的 selinux 权限</h3>
<p>需要在 device/mediatek/sepolicy/basic/non_plat 路径下添加相关的 selinux 权限。</p>
<p>device/mediatek/sepolicy/basic/non_plat/device.te</p>
<pre><code>type secos_block_device, dev_type;
</code></pre>
<p>device/mediatek/sepolicy/basic/non_plat/file.te</p>
<pre><code>type secos_file, file_type, data_file_type;
</code></pre>
<p>device/mediatek/sepolicy/basic/non_plat/file_contexts</p>
<pre><code>#############################
# secos files
/secos(/.*)?		u:object_r:secos_file:s0
/dev/block/platform/mtk-msdc\.0/[0-9]+\.(msdc|MSDC)0/by-name/secos	u:object_r:secos_block_device:s0
</code></pre>
<p>在这里我在这里踩得坑，因为我一开始要挂在 /mnt/vendor/ 目录下面的。 因此，我在这里把
/secos(/.<em>)? 写成了 /mnt/vendor/secos(/.</em>)? 。因此老是出现了编译错误: failed with error code 4 的错误。
一开始并没有意识到这个错误。 导致在这里花费了很长的时间。这个将在随后说。
device/mediatek/sepolicy/basic/non_plat/fsck.te</p>
<pre><code>allow fsck secos_block_device:blk_file rw_file_perms;
</code></pre>
<p>device/mediatek/sepolicy/basic/non_plat/init.te</p>
<pre><code>allow init secos_block_device:blk_file { write read };
allow init secos_block_device:blk_file relabelto;
</code></pre>
<h3 id="添加分区的-image-文件">添加分区的 IMAGE 文件</h3>
<p>添加分区的大小信息到一个 txt 文件中. 创建image 文件的时候, 需要用的到.</p>
<pre><code class="language-makefile">$(if $(BOARD_OEMIMAGE_PARTITION_SIZE),$(hide) echo &quot;oem_size=$(BOARD_OEMIMAGE_PARTITION_SIZE)&quot; &gt;&gt; $(1))
$(if $(BOARD_OEMIMAGE_JOURNAL_SIZE),$(hide) echo &quot;oem_journal_size=$(BOARD_OEMIMAGE_JOURNAL_SIZE)&quot; &gt;&gt; $(1))
$(if $(BOARD_OEMIMAGE_EXTFS_INODE_COUNT),$(hide) echo &quot;oem_extfs_inode_count=$(BOARD_OEMIMAGE_EXTFS_INODE_COUNT)&quot; &gt;&gt; $(1))
$(if $(BOARD_OEMIMAGE_EXTFS_RSV_PCT),$(hide) echo &quot;oem_extfs_rsv_pct=$(BOARD_OEMIMAGE_EXTFS_RSV_PCT)&quot; &gt;&gt; $(1))
$(if $(BOARD_ANTCOMMONIMAGE_PARTITION_SIZE),$(hide) echo &quot;antcommon_size=$(BOARD_ANTCOMMONIMAGE_PARTITION_SIZE)&quot; &gt;&gt; $(1))
$(if $(BOARD_SECOSIMAGE_PARTITION_SIZE),$(hide) echo &quot;secos_size=$(BOARD_SECOSIMAGE_PARTITION_SIZE)&quot; &gt;&gt; $(1))
$(if $(INTERNAL_USERIMAGES_SPARSE_EXT_FLAG),$(hide) echo &quot;extfs_sparse_flag=$(INTERNAL_USERIMAGES_SPARSE_EXT_FLAG)&quot; &gt;&gt; $(1))
</code></pre>
<p>即使你设置了 BOARD_SECOSIMAGE_PARTITION_SIZE, 但是 BOARD_SECOSIMAGE_PARTITION_SIZE 不一定是你设置的的大小．</p>
<p>device/mediatek/build/build/tools/ptgen/MT6761/ptgen.pl 里会根据分区的大小， 各自对齐一下. 所以他的大小会改变．
比如我这里在分区表里给的大小时 45120 KB, 但是实际上得到的是 52 MB. 这个你可以在编译完的生成目录的 ninja 文件里搜索到实际的大小.</p>
<pre><code class="language-perl">if ($part-&gt;{Type} eq &quot;EXT4&quot; || $part-&gt;{Type} eq &quot;FAT&quot;)
{
	$temp = $part-&gt;{Size_KB} * 1024;
	my $raw_name = GetABPartBaseName($part-&gt;{Partition_Name});
	if ($part-&gt;{Partition_Name} ne &quot;${raw_name}_b&quot;)   # do not print for _b partition, its redundant setting
	{
		printf $part_size_fh (&quot;BOARD_%sIMAGE_PARTITION_SIZE:=%d\n&quot;,uc($raw_name),$temp);
		if (exists $mountPointMapList{$raw_name})
		{
			if ($mountPointMapList{$raw_name} ne &quot;&quot;)
			{
				printf $part_size_fh (&quot;MTK_BOARD_ROOT_EXTRA_SYMLINKS += /mnt/vendor/%s:%s\n&quot;, $mountPointMapList{$raw_name}, $mountPointMapList{$raw_name});
			}
		}
		else
		{
			printf $part_size_fh (&quot;MTK_BOARD_ROOT_EXTRA_SYMLINKS += /mnt/vendor/%s:%s\n&quot;, $raw_name, $raw_name);
		}
	}
}
if ($ArgList{MTK_BOARD_AVB_ENABLE} eq &quot;true&quot;)
{
	if ($part-&gt;{Partition_Name} =~ /^boot(_a)?$/i || $part-&gt;{Partition_Name} =~ /^recovery?$/i)
	{
		$temp = $part-&gt;{Size_KB} * 1024;
		my $raw_name = GetABPartBaseName($part-&gt;{Partition_Name});
		printf $part_size_fh (&quot;BOARD_%sIMAGE_PARTITION_SIZE:=%d\n&quot;,uc($raw_name),$temp);
	}
	if ($part-&gt;{Partition_Name} =~ /^dtbo(1|_a)?$/i)
	{
		$temp = $part-&gt;{Size_KB} * 1024;
		my $raw_name = GetPartBaseName($part-&gt;{Partition_Name});
		printf $part_size_fh (&quot;BOARD_%sIMG_PARTITION_SIZE:=%d\n&quot;,uc($raw_name),$temp);
	}
}


</code></pre>
<p>将这些添加的宏, 放到编译 ROM 包里面.</p>
<pre><code class="language-makefile"># 建立　target files 与　secos.img 文件
# Depending on the various images guarantees that the underlying
# directories are up-to-date.
$(BUILT_TARGET_FILES_PACKAGE): \
		$(INSTALLED_BOOTIMAGE_TARGET) \
		$(MTK_BOOTIMAGE_TARGET) \
		$(INSTALLED_RADIOIMAGE_TARGET) \
		$(INSTALLED_RECOVERYIMAGE_TARGET) \
		$(FULL_SYSTEMIMAGE_DEPS) \
		$(INSTALLED_USERDATAIMAGE_TARGET) \
		$(INSTALLED_CACHEIMAGE_TARGET) \
		$(INSTALLED_SECOSIMAGE_TARGET) \
		$(INSTALLED_VENDORIMAGE_TARGET) \
		$(INSTALLED_PRODUCTIMAGE_TARGET) \
		$(INSTALLED_VBMETAIMAGE_TARGET) \
		$(INSTALLED_DTBOIMAGE_TARGET) \
		$(INTERNAL_SYSTEMOTHERIMAGE_FILES) \
		$(INSTALLED_ANDROID_INFO_TXT_TARGET) \
		$(INSTALLED_KERNEL_TARGET) \
		$(INSTALLED_2NDBOOTLOADER_TARGET) \

</code></pre>
<pre><code class="language-makefile"># -----------------------------------------------------------------
# secos image , 编译生成相关的 image 文件
INTERNAL_SECOSIMAGE_FILES := \
	$(filter $(TARGET_OUT_SECOS)/%,$(ALL_DEFAULT_INSTALLED_MODULES))

secosimage_intermediates := \
	$(call intermediates-dir-for,PACKAGING,secos)
BUILT_SECOSIMAGE_TARGET := $(PRODUCT_OUT)/secos.img

define build-secosimage-target
	$(call pretty,&quot;Target secos fs image: $(INSTALLED_SECOSIMAGE_TARGET)&quot;)
	@mkdir -p $(TARGET_OUT_SECOS)
	@mkdir -p $(secosimage_intermediates) &amp;&amp; rm -rf $(secosimage_intermediates)/secos_image_info.txt
	$(call generate-userimage-prop-dictionary, $(secosimage_intermediates)/secos_image_info.txt, skip_fsck=true)
	$(hide) PATH=$(foreach p,$(INTERNAL_USERIMAGES_BINARY_PATHS),$(p):)$$PATH \
	./build/tools/releasetools/build_image.py \
	$(TARGET_OUT_SECOS) $(secosimage_intermediates)/secos_image_info.txt $(INSTALLED_SECOSIMAGE_TARGET) $(TARGET_OUT)
	$(hide) $(call assert-max-image-size,$(INSTALLED_SECOSIMAGE_TARGET),$(BOARD_SECOSIMAGE_PARTITION_SIZE))
endef

# We just build this directly to the install location.
INSTALLED_SECOSIMAGE_TARGET := $(BUILT_SECOSIMAGE_TARGET)
$(INSTALLED_SECOSIMAGE_TARGET): $(INTERNAL_USERIMAGES_DEPS) $(INTERNAL_SECOSIMAGE_FILES)
	$(build-secosimage-target)

.PHONY: secosimage-nodeps
secosimage-nodeps: | $(INTERNAL_USERIMAGES_DEPS)
	$(build-secosimage-target)


</code></pre>
<p>将生成的 image 文件 添加到target_file 文件里. 如果你不需要升级的话, 感觉不需要添加这个的.</p>
<pre><code class="language-makefile">ifdef BOARD_PREBUILT_VENDORIMAGE
	$(hide) mkdir -p $(zip_root)/IMAGES
	$(hide) cp $(INSTALLED_VENDORIMAGE_TARGET) $(zip_root)/IMAGES/
endif
# 生成的　image 文件放置　target_file 的IMAGES路径下面
ifdef BOARD_SECOSIMAGE_FILE_SYSTEM_TYPE
	$(hide) mkdir -p $(zip_root)/IMAGES
	$(hide) cp $(INSTALLED_SECOSIMAGE_TARGET) $(zip_root)/IMAGES/
endif
ifdef BOARD_PREBUILT_PRODUCTIMAGE
	$(hide) mkdir -p $(zip_root)/IMAGES
	$(hide) cp $(INSTALLED_PRODUCTIMAGE_TARGET) $(zip_root)/IMAGES/
endif
</code></pre>
<pre><code class="language-makefile"># 编译整个刷机包的
# Build files and then package it into the rom formats
.PHONY: droidcore
droidcore: files \
	systemimage \
	$(INSTALLED_BOOTIMAGE_TARGET) \
	$(MTK_BOOTIMAGE_TARGET) \
	$(INSTALLED_RECOVERYIMAGE_TARGET) \
	$(INSTALLED_VBMETAIMAGE_TARGET) \
	$(INSTALLED_USERDATAIMAGE_TARGET) \
	$(INSTALLED_CACHEIMAGE_TARGET) \
	$(INSTALLED_ANTCOMMONIMAGE_TARGET) \
	$(INSTALLED_SECOSIMAGE_TARGET) \
	$(INSTALLED_BPTIMAGE_TARGET) \
	$(INSTALLED_VENDORIMAGE_TARGET) \
	$(INSTALLED_PRODUCTIMAGE_TARGET) \
	$(INSTALLED_SYSTEMOTHERIMAGE_TARGET) \
	$(INSTALLED_FILES_FILE) \
	$(INSTALLED_FILES_FILE_VENDOR) \
	$(INSTALLED_FILES_FILE_PRODUCT) \
	$(INSTALLED_FILES_FILE_SYSTEMOTHER) \
	soong_docs

</code></pre>
<pre><code class="language-makefile">.PHONY: cacheimage
cacheimage: $(INSTALLED_CACHEIMAGE_TARGET)

# 添加单独编译的代码
.PHONY: secosimage
secosimage: $(INSTALLED_SECOSIMAGE_TARGET)

.PHONY: bptimage
bptimage: $(INSTALLED_BPTIMAGE_TARGET)

</code></pre>
<p>build/tools/releasetools/build_image.py</p>
<pre><code class="language-py">  elif mount_point == &quot;oem&quot;:
    copy_prop(&quot;fs_type&quot;, &quot;fs_type&quot;)
    copy_prop(&quot;oem_size&quot;, &quot;partition_size&quot;)
    if not copy_prop(&quot;oem_journal_size&quot;, &quot;journal_size&quot;):
      d[&quot;journal_size&quot;] = &quot;0&quot;
    copy_prop(&quot;oem_extfs_inode_count&quot;, &quot;extfs_inode_count&quot;)
    if not copy_prop(&quot;oem_extfs_rsv_pct&quot;, &quot;extfs_rsv_pct&quot;):
      d[&quot;extfs_rsv_pct&quot;] = &quot;0&quot;
  elif mount_point == &quot;secos&quot;:
    # out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt 读取的是这个文件
    copy_prop(&quot;fs_type&quot;, &quot;fs_type&quot;)
    copy_prop(&quot;secos_size&quot;, &quot;partition_size&quot;)
    copy_prop(&quot;secos_verity_block_device&quot;, &quot;verity_block_device&quot;)
  d[&quot;partition_name&quot;] = mount_point
  return d

</code></pre>
<pre><code class="language-py">    elif image_filename == &quot;product.img&quot;:
      mount_point = &quot;product&quot;
    elif image_filename == &quot;secos.img&quot;:
      mount_point = &quot;secos&quot;
    else:
      print(&quot;error: unknown image file name &quot;, image_filename, file=sys.stderr)
      sys.exit(1)
</code></pre>
<h2 id="出现的错误">出现的错误</h2>
<h4 id="错误索引">错误索引</h4>
<pre><code>相关配置项的注意，Type，Download_File，Download，OTA_Update，FastBoot_Download, 
命令行之前需要有一个TAB,
生成了相关的image 但是没有放在　target_files_package
编译出现了failed with exit 4，　&quot;/mnt/vendor/secos&quot; 还是 &quot;/secos&quot;
挂载参数错误导致的无法开机
修改参数之后开机没有挂载上去skipping, slotselect参数
无法挂载在根目录/
</code></pre>
<h4 id="分区表的各项注意">分区表的各项注意</h4>
<p>Type，　　文件的分区格式　有Raw data 和 EXT4
Download_File， 刷机的时的文件的文件名称，比如system.img
Download，　　　　是否通过刷机的方式，应该和　Download_File保持一致
OTA_Update，　　　是否通过OTA升级的方式升级该分区，如果加入的不是AB分区，建议写N
FastBoot_Download,  是否通过FastBoot的方式下载</p>
<h4 id="missing-separator-错误">missing separator 错误</h4>
<pre><code>mobicore - including vendor/mediatek/proprietary/trustzone/trustonic/source/external/mobicore/common/400b/Android.mk
including vendor/mediatek/widevine_tlib/Android.mk ...
[950/950] including vendor/nxp/Android.mk ...
build/make/core/Makefile:2920: error: missing separator.
14:30:18 ckati failed with: exit status 1
***************************************************
  end android build
***************************************************
</code></pre>
<p>这个是因为Makefile 里使用命令行之前，需要空出TAB键</p>
<h4 id="failed-with-exit-code-4">failed with exit code 4</h4>
<pre><code>img-1 size:0x5c0
add index1 image, this is final image
img name not match,exit!!
[  0% 27/50746] build check-kernel-config
[  0% 28/50746] Copying: out/target/product/ax2129/system/etc/tee.img
[  0% 29/50746] Target secos fs image: out/target/product/ax2129/secos.img
FAILED: out/target/product/ax2129/secos.img 
/bin/bash -c &quot;(mkdir -p out/target/product/ax2129/secos ) &amp;&amp; (mkdir -p out/target/product/ax2129/obj/PACKAGING/secos_intermediates &amp;&amp; rm -rf out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;ext_mkuserimg=mkuserimg_mke2fs.sh\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;fs_type=ext4\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;system_size=3221225472\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;userdata_size=2778464256\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;vendor_fs_type=ext4\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;vendor_size=838860800\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;extfs_sparse_flag=-s\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;squashfs_sparse_flag=-s\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;selinux_fc=out/target/product/ax2129/obj/ETC/file_contexts.bin_intermediates/file_contexts.bin\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;system_verity_block_device=/dev/block/platform/bootdevice/by-name/system\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;vendor_verity_block_device=/dev/block/platform/bootdevice/by-name/vendor\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_avbtool=avbtool\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_hashtree_enable=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_add_hashtree_footer_args=--rollback_index 0 --setup_as_rootfs_from_kernel\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_key_path=device/mediatek/common/system_prvk.pem\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_algorithm=SHA256_RSA2048\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_rollback_index_location=2\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_vendor_hashtree_enable=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_vendor_add_hashtree_footer_args=\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_product_hashtree_enable=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_product_add_hashtree_footer_args=\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;recovery_as_boot=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;system_root_image=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt; echo \&quot;ramdisk_dir=out/target/product/ax2129/root\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;skip_fsck=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;secos_size=50331648\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;secos_fs_type=ext4\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (PATH=out/host/linux-x86/bin/:\$PATH ./build/tools/releasetools/build_image.py out/target/product/ax2129/secos out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt out/target/product/ax2129/secos.img out/target/product/ax2129/system ) &amp;&amp; (size=\$(for i in out/target/product/ax2129/secos.img; do stat --format \&quot;%s\&quot; \&quot;\$i\&quot; | tr -d '\\n'; echo +; done; echo 0); total=\$(( \$( echo \&quot;\$size\&quot; ) )); printname=\$(echo -n \&quot;out/target/product/ax2129/secos.img\&quot; | tr \&quot; \&quot; +); maxsize=\$((50331648)); if [ \&quot;\$total\&quot; -gt \&quot;\$maxsize\&quot; ]; then echo \&quot;error: \$printname too large (\$total &gt; \$maxsize)\&quot;; false; elif [ \&quot;\$total\&quot; -gt \$((maxsize - 32768)) ]; then echo \&quot;WARNING: \$printname approaching size limit (\$total now; limit \$maxsize)\&quot;; fi )&quot;
error: failed to build out/target/product/ax2129/secos.img from out/target/product/ax2129/secos
Error: '['mkuserimg_mke2fs.sh', '-s', 'out/target/product/ax2129/secos', 'out/target/product/ax2129/secos.img', 'ext4', 'secos', '50331648', '-D', 'out/target/product/ax2129/system', '-L', 'secos', 'out/target/product/ax2129/obj/ETC/file_contexts.bin_intermediates/file_contexts.bin']' failed with exit code 4:
MKE2FS_CONFIG=./system/extras/ext4_utils/mke2fs.conf mke2fs -L secos -E android_sparse -t ext4 -b 4096 out/target/product/ax2129/secos.img 12288
mke2fs 1.43.3 (04-Sep-2016)
Creating filesystem with 12288 4k blocks and 12288 inodes

Allocating group tables: 0/1   done                            
Writing inode tables: 0/1   done                            
Creating journal (1024 blocks): done
Writing superblocks and filesystem accounting information: 0/1   done

e2fsdroid -p out/target/product/ax2129/system -S out/target/product/ax2129/obj/ETC/file_contexts.bin_intermediates/file_contexts.bin -f out/target/product/ax2129/secos -a /secos out/target/product/ax2129/secos.img
set_selinux_xattr: Unknown code ____ 255 searching for label &quot;/secos&quot;

[  0% 30/50746] sign: out/target/product/ax2129/tee.img
writing RSA key
writing RSA key
writing RSA key

</code></pre>
<p>一开始我以为时　mkuserimg_mke2fs.sh　这个行的命令行出现了错误，但是把这个命令行单独拿出来，执行命令，没有发现任何错误．
后来我怀疑是后面的的计算image 大小的出现了错误．　这个image的大小超出了系统分配的分区的大小．实际上也不是真正的错误原因.</p>
<pre><code>(size=\$(for i in out/target/product/ax2129/secos.img; do stat --format \&quot;%s\&quot; \&quot;\$i\&quot; | tr -d '\\n'; echo +; done; echo 0); total=\$(( \$( echo \&quot;\$size\&quot; ) )); printname=\$(echo -n \&quot;out/target/product/ax2129/secos.img\&quot; | tr \&quot; \&quot; +); maxsize=\$((50331648)); if [ \&quot;\$total\&quot; -gt \&quot;\$maxsize\&quot; ]; then echo \&quot;error: \$printname too large (\$total &gt; \$maxsize)\&quot;; false; elif [ \&quot;\$total\&quot; -gt \$((maxsize - 32768)) ]; then echo \&quot;WARNING: \$printname approaching size limit (\$total now; limit \$maxsize)\&quot;; fi )&quot;
</code></pre>
<p>out/host/linux-x86/bin/mkuserimg_mke2fs.sh
system/extras/ext4_utils/mkuserimg_mke2fs.sh</p>
<pre><code class="language-makefile"># $(1): The file to check
define get-file-size
stat --format &quot;%s&quot; &quot;$(1)&quot; | tr -d '\n'
endef

</code></pre>
<pre><code class="language-makefile"># INSTALLED_SECOSIMAGE_TARGET  out/target/product/ax2129/secos.img 
# BOARD_SECOSIMAGE_PARTITION_SIZE  
# $(hide) $(call assert-max-image-size,$(INSTALLED_SECOSIMAGE_TARGET),$(BOARD_SECOSIMAGE_PARTITION_SIZE))
# $(1): The file(s) to check (often $@)
# $(2): The partition size.
define assert-max-image-size
$(if $(2), \
  size=$$(for i in $(1); do $(call get-file-size,$$i); echo +; done; echo 0); \
  total=$$(( $$( echo &quot;$$size&quot; ) )); \
  printname=$$(echo -n &quot;$(1)&quot; | tr &quot; &quot; +); \
  maxsize=$$(($(2))); \
  if [ &quot;$$total&quot; -gt &quot;$$maxsize&quot; ]; then \
    echo &quot;error: $$printname too large ($$total &gt; $$maxsize)&quot;; \
    false; \
  elif [ &quot;$$total&quot; -gt $$((maxsize - 32768)) ]; then \
    echo &quot;WARNING: $$printname approaching size limit ($$total now; limit $$maxsize)&quot;; \
  fi \
 , \
  true \
 )
endef
</code></pre>
<p>但是经过详细的计算，得出还是没超过．所以这个也不似root cause．</p>
<p>随后，请教别人, 出现错误的地方是后面的 selinux相关的．</p>
<pre><code>e2fsdroid -p out/target/product/ax2129/system -S out/target/product/ax2129/obj/ETC/file_contexts.bin_intermediates/file_contexts.bin -f out/target/product/ax2129/secos -a /secos out/target/product/ax2129/secos.img
set_selinux_xattr: Unknown code ____ 255 searching for label &quot;/secos&quot;
</code></pre>
<p>e2fsdroid 是一个命令。他的源码在 external/e2fsprogs 下面。</p>
<pre><code>// external/e2fsprogs/contrib/android/perms.c
static errcode_t set_selinux_xattr(ext2_filsys fs, ext2_ino_t ino,
				   struct inode_params *params)
{
	errcode_t retval;
	char *secontext = NULL;
	struct ext2_inode inode;

	if (params-&gt;sehnd == NULL)
		return 0;

	retval = ext2fs_read_inode(fs, ino, &amp;inode);
	if (retval) {
		com_err(__func__, retval,
			_(&quot;while reading inode %u&quot;), ino);
		return retval;
	}

	retval = selabel_lookup(params-&gt;sehnd, &amp;secontext, params-&gt;filename,
				inode.i_mode);
	if (retval &lt; 0) {
		com_err(__func__, retval,
			_(&quot;searching for label \&quot;%s\&quot;&quot;), params-&gt;filename);
		exit(1);
	}

	retval = ino_add_xattr(fs, ino,  &quot;security.&quot; XATTR_SELINUX_SUFFIX,
			       secontext, strlen(secontext) + 1);

	freecon(secontext);
	return retval;
}

</code></pre>
<p>有此可以知道他进入了 selabel_lookup 函数</p>
<pre><code>// external/selinux/libselinux/src/label.c
int selabel_lookup(struct selabel_handle *rec, char **con,
		   const char *key, int type)
{
	struct selabel_lookup_rec *lr;

	lr = selabel_lookup_common(rec, 1, key, type);
	if (!lr)
		return -1;

	*con = strdup(lr-&gt;ctx_trans);
	return *con ? 0 : -1;
}
</code></pre>
<p>这个错误的主要原因是 /secos(/.<em>)? 写成了 /mnt/vendor/secos(/.</em>)? 还不太理解为什么不能这么写</p>
<pre><code>sig:out/target/product/ax2129/sig/tee.sig
output path:out/target/product/ax2129/tee-verified.img
[  0% 46/50745] Export includes file: out/target/product/ax2129/obj/STATIC_LIBRARIES/libcam.halsensor.custom_intermediates/custgen.config_metadata.h -- out/target/product/ax2129/obj_arm/STATIC_LIBRARIES/libcam.halsensor.custom_intermediates/export_includes
[  0% 47/50744] Export includes file: out/target/product/ax2129/obj/STATIC_LIBRARIES/libcam.halsensor.custom_intermediates/custgen.config_metadata.h -- out/target/product/ax2129/obj/STATIC_LIBRARIES/libcam.halsensor.custom_intermediates/export_includes
[  0% 48/50743] //prebuilts/sdk/current/extras/material-design:android-support-design-bottomsheet-nodeps overlay resource file list [common]
[  0% 49/50743] Target secos fs image: out/target/product/ax2129/secos.img
FAILED: out/target/product/ax2129/secos.img 
/bin/bash -c &quot;(mkdir -p out/target/product/ax2129/secos ) &amp;&amp; (mkdir -p out/target/product/ax2129/obj/PACKAGING/secos_intermediates &amp;&amp; rm -rf out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;ext_mkuserimg=mkuserimg_mke2fs.sh\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;fs_type=ext4\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;system_size=3221225472\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;userdata_size=2778464256\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;vendor_fs_type=ext4\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;vendor_size=838860800\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;extfs_sparse_flag=-s\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;squashfs_sparse_flag=-s\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;selinux_fc=out/target/product/ax2129/obj/ETC/file_contexts.bin_intermediates/file_contexts.bin\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;system_verity_block_device=/dev/block/platform/bootdevice/by-name/system\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;vendor_verity_block_device=/dev/block/platform/bootdevice/by-name/vendor\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_avbtool=avbtool\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_hashtree_enable=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_add_hashtree_footer_args=--rollback_index 0 --setup_as_rootfs_from_kernel\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_key_path=device/mediatek/common/system_prvk.pem\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_algorithm=SHA256_RSA2048\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_system_rollback_index_location=2\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_vendor_hashtree_enable=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_vendor_add_hashtree_footer_args=\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_product_hashtree_enable=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;avb_product_add_hashtree_footer_args=\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;recovery_as_boot=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;system_root_image=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt; echo \&quot;ramdisk_dir=out/target/product/ax2129/root\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;skip_fsck=true\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;secos_size=50331648\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (echo \&quot;secos_fs_type=ext4\&quot; &gt;&gt;  out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt ) &amp;&amp; (PATH=out/host/linux-x86/bin/:\$PATH ./build/tools/releasetools/build_image.py out/target/product/ax2129/secos out/target/product/ax2129/obj/PACKAGING/secos_intermediates/secos_image_info.txt out/target/product/ax2129/secos.img ) &amp;&amp; (size=\$(for i in out/target/product/ax2129/secos.img; do stat --format \&quot;%s\&quot; \&quot;\$i\&quot; | tr -d '\\n'; echo +; done; echo 0); total=\$(( \$( echo \&quot;\$size\&quot; ) )); printname=\$(echo -n \&quot;out/target/product/ax2129/secos.img\&quot; | tr \&quot; \&quot; +); maxsize=\$((50331648)); if [ \&quot;\$total\&quot; -gt \&quot;\$maxsize\&quot; ]; then echo \&quot;error: \$printname too large (\$total &gt; \$maxsize)\&quot;; false; elif [ \&quot;\$total\&quot; -gt \$((maxsize - 32768)) ]; then echo \&quot;WARNING: \$printname approaching size limit (\$total now; limit \$maxsize)\&quot;; fi )&quot;

Builds output_image from the given input_directory, properties_file,
and writes the image to target_output_directory.

Usage:  build_image.py input_directory properties_file output_image \
            target_output_directory

[  0% 50/50743] //prebuilts/sdk/current/extras/material-design:android-support-design-bottomsheet-nodeps aapt2 link [common]
[  0% 51/50743] build /mnt/code/huaqin/AX2129_D/out/target/product/ax2129/obj/BOOTLOADER_OBJ/build-ax2129/lk.img
make: Entering directory `/mnt/code/huaqin/AX2129_D/vendor/mediatek/proprietary/bootable/bootloader/lk'


</code></pre>
<pre><code class="language-cpp">int fs_mgr_mount_all(struct fstab *fstab, int mount_mode)
{
    int i = 0;
    int encryptable = FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE;
    int error_count = 0;
    int mret = -1;
    int mount_errno = 0;
    int attempted_idx = -1;
    FsManagerAvbUniquePtr avb_handle(nullptr);

    if (!fstab) {
        return FS_MGR_MNTALL_FAIL;
    }

    for (i = 0; i &lt; fstab-&gt;num_entries; i++) {
        /* Don't mount entries that are managed by vold or not for the mount mode*/
        if ((fstab-&gt;recs[i].fs_mgr_flags &amp; (MF_VOLDMANAGED | MF_RECOVERYONLY)) ||
             ((mount_mode == MOUNT_MODE_LATE) &amp;&amp; !fs_mgr_is_latemount(&amp;fstab-&gt;recs[i])) ||
             ((mount_mode == MOUNT_MODE_EARLY) &amp;&amp; fs_mgr_is_latemount(&amp;fstab-&gt;recs[i]))) {
            continue;
        }

        /* Skip swap and raw partition entries such as boot, recovery, etc */
        if (!strcmp(fstab-&gt;recs[i].fs_type, &quot;swap&quot;) ||
            !strcmp(fstab-&gt;recs[i].fs_type, &quot;emmc&quot;) ||
            !strcmp(fstab-&gt;recs[i].fs_type, &quot;mtd&quot;)) {
            continue;
        }

        /* Skip mounting the root partition, as it will already have been mounted */
        if (!strcmp(fstab-&gt;recs[i].mount_point, &quot;/&quot;)) {
            if ((fstab-&gt;recs[i].fs_mgr_flags &amp; MS_RDONLY) != 0) {
                fs_mgr_set_blk_ro(fstab-&gt;recs[i].blk_device);
            }
            continue;
        }

        /* Translate LABEL= file system labels into block devices */
        if (is_extfs(fstab-&gt;recs[i].fs_type)) {
            int tret = translate_ext_labels(&amp;fstab-&gt;recs[i]);
            if (tret &lt; 0) {
                LERROR &lt;&lt; &quot;Could not translate label to block device&quot;;
                continue;
            }
        }

        if (fstab-&gt;recs[i].fs_mgr_flags &amp; MF_WAIT &amp;&amp;
            !fs_mgr_wait_for_file(fstab-&gt;recs[i].blk_device, 20s)) {
            LERROR &lt;&lt; &quot;Skipping '&quot; &lt;&lt; fstab-&gt;recs[i].blk_device &lt;&lt; &quot;' during mount_all&quot;;
            continue;
        }

        if (fstab-&gt;recs[i].fs_mgr_flags &amp; MF_AVB) {
            if (!avb_handle) {
                avb_handle = FsManagerAvbHandle::Open(*fstab);
                if (!avb_handle) {
                    LERROR &lt;&lt; &quot;Failed to open FsManagerAvbHandle&quot;;
                    return FS_MGR_MNTALL_FAIL;
                }
            }
            if (avb_handle-&gt;SetUpAvbHashtree(&amp;fstab-&gt;recs[i], true /* wait_for_verity_dev */) ==
                SetUpAvbHashtreeResult::kFail) {
                LERROR &lt;&lt; &quot;Failed to set up AVB on partition: &quot;
                       &lt;&lt; fstab-&gt;recs[i].mount_point &lt;&lt; &quot;, skipping!&quot;;
                /* Skips mounting the device. */
                continue;
            }
        } else if ((fstab-&gt;recs[i].fs_mgr_flags &amp; MF_VERIFY)) {
            int rc = fs_mgr_setup_verity(&amp;fstab-&gt;recs[i], true);
            if (__android_log_is_debuggable() &amp;&amp;
                    (rc == FS_MGR_SETUP_VERITY_DISABLED ||
                     rc == FS_MGR_SETUP_VERITY_SKIPPED)) {
                LINFO &lt;&lt; &quot;Verity disabled&quot;;
            } else if (rc != FS_MGR_SETUP_VERITY_SUCCESS) {
                LERROR &lt;&lt; &quot;Could not set up verified partition, skipping!&quot;;
                continue;
            }
        }

        int last_idx_inspected;
        int top_idx = i;

        mret = mount_with_alternatives(fstab, i, &amp;last_idx_inspected, &amp;attempted_idx);
        i = last_idx_inspected;
        mount_errno = errno;

        /* Deal with encryptability. */
        if (!mret) {
            int status = handle_encryptable(&amp;fstab-&gt;recs[attempted_idx]);

            if (status == FS_MGR_MNTALL_FAIL) {
                /* Fatal error - no point continuing */
                return status;
            }

            if (status != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) {
                if (encryptable != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) {
                    // Log and continue
                    LERROR &lt;&lt; &quot;Only one encryptable/encrypted partition supported&quot;;
                }
                encryptable = status;
                if (status == FS_MGR_MNTALL_DEV_NEEDS_METADATA_ENCRYPTION) {
                    if (!call_vdc(
                            {&quot;cryptfs&quot;, &quot;encryptFstab&quot;, fstab-&gt;recs[attempted_idx].mount_point})) {
                        LERROR &lt;&lt; &quot;Encryption failed&quot;;
                        return FS_MGR_MNTALL_FAIL;
                    }
                }
            }

            /* Success!  Go get the next one */
            continue;
        }

        bool wiped = partition_wiped(fstab-&gt;recs[top_idx].blk_device);
        bool crypt_footer = false;
        if (mret &amp;&amp; mount_errno != EBUSY &amp;&amp; mount_errno != EACCES &amp;&amp;
            fs_mgr_is_formattable(&amp;fstab-&gt;recs[top_idx]) &amp;&amp; wiped) {
            /* top_idx and attempted_idx point at the same partition, but sometimes
             * at two different lines in the fstab.  Use the top one for formatting
             * as that is the preferred one.
             */
            LERROR &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): &quot; &lt;&lt; fstab-&gt;recs[top_idx].blk_device
                   &lt;&lt; &quot; is wiped and &quot; &lt;&lt; fstab-&gt;recs[top_idx].mount_point
                   &lt;&lt; &quot; &quot; &lt;&lt; fstab-&gt;recs[top_idx].fs_type
                   &lt;&lt; &quot; is formattable. Format it.&quot;;
            if (fs_mgr_is_encryptable(&amp;fstab-&gt;recs[top_idx]) &amp;&amp;
                strcmp(fstab-&gt;recs[top_idx].key_loc, KEY_IN_FOOTER)) {
                int fd = open(fstab-&gt;recs[top_idx].key_loc, O_WRONLY);
                if (fd &gt;= 0) {
                    LINFO &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): also wipe &quot;
                          &lt;&lt; fstab-&gt;recs[top_idx].key_loc;
                    wipe_block_device(fd, get_file_size(fd));
                    close(fd);
                } else {
                    PERROR &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): &quot;
                           &lt;&lt; fstab-&gt;recs[top_idx].key_loc &lt;&lt; &quot; wouldn't open&quot;;
                }
            } else if (fs_mgr_is_encryptable(&amp;fstab-&gt;recs[top_idx]) &amp;&amp;
                !strcmp(fstab-&gt;recs[top_idx].key_loc, KEY_IN_FOOTER)) {
                crypt_footer = true;
            }
            if (fs_mgr_do_format(&amp;fstab-&gt;recs[top_idx], crypt_footer) == 0) {
                /* Let's replay the mount actions. */
                i = top_idx - 1;
                continue;
            } else {
                LERROR &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): Format failed. &quot;
                       &lt;&lt; &quot;Suggest recovery...&quot;;
                encryptable = FS_MGR_MNTALL_DEV_NEEDS_RECOVERY;
                continue;
            }
        }

        /* mount(2) returned an error, handle the encryptable/formattable case */
        if (mret &amp;&amp; mount_errno != EBUSY &amp;&amp; mount_errno != EACCES &amp;&amp;
            fs_mgr_is_encryptable(&amp;fstab-&gt;recs[attempted_idx])) {
            if (wiped) {
                LERROR &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): &quot;
                       &lt;&lt; fstab-&gt;recs[attempted_idx].blk_device
                       &lt;&lt; &quot; is wiped and &quot;
                       &lt;&lt; fstab-&gt;recs[attempted_idx].mount_point &lt;&lt; &quot; &quot;
                       &lt;&lt; fstab-&gt;recs[attempted_idx].fs_type
                       &lt;&lt; &quot; is encryptable. Suggest recovery...&quot;;
                encryptable = FS_MGR_MNTALL_DEV_NEEDS_RECOVERY;
                continue;
            } else {
                /* Need to mount a tmpfs at this mountpoint for now, and set
                 * properties that vold will query later for decrypting
                 */
                LERROR &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): possibly an encryptable blkdev &quot;
                       &lt;&lt; fstab-&gt;recs[attempted_idx].blk_device
                       &lt;&lt; &quot; for mount &quot; &lt;&lt; fstab-&gt;recs[attempted_idx].mount_point
                       &lt;&lt; &quot; type &quot; &lt;&lt; fstab-&gt;recs[attempted_idx].fs_type;
                if (fs_mgr_do_tmpfs_mount(fstab-&gt;recs[attempted_idx].mount_point) &lt; 0) {
                    ++error_count;
                    continue;
                }
            }
            encryptable = FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED;
        } else if (mret &amp;&amp; mount_errno != EBUSY &amp;&amp; mount_errno != EACCES &amp;&amp;
                   should_use_metadata_encryption(&amp;fstab-&gt;recs[attempted_idx])) {
            if (!call_vdc({&quot;cryptfs&quot;, &quot;mountFstab&quot;, fstab-&gt;recs[attempted_idx].mount_point})) {
                ++error_count;
            }
            encryptable = FS_MGR_MNTALL_DEV_IS_METADATA_ENCRYPTED;
            continue;
        } else {
            // fs_options might be null so we cannot use PERROR &lt;&lt; directly.
            // Use StringPrintf to output &quot;(null)&quot; instead.
            if (fs_mgr_is_nofail(&amp;fstab-&gt;recs[attempted_idx])) {
                PERROR &lt;&lt; android::base::StringPrintf(
                    &quot;Ignoring failure to mount an un-encryptable or wiped &quot;
                    &quot;partition on %s at %s options: %s&quot;,
                    fstab-&gt;recs[attempted_idx].blk_device, fstab-&gt;recs[attempted_idx].mount_point,
                    fstab-&gt;recs[attempted_idx].fs_options);
            } else {
                PERROR &lt;&lt; android::base::StringPrintf(
                    &quot;Failed to mount an un-encryptable or wiped partition &quot;
                    &quot;on %s at %s options: %s&quot;,
                    fstab-&gt;recs[attempted_idx].blk_device, fstab-&gt;recs[attempted_idx].mount_point,
                    fstab-&gt;recs[attempted_idx].fs_options);
                ++error_count;
            }
            continue;
        }
    }

    if (error_count) {
        return FS_MGR_MNTALL_FAIL;
    } else {
        return encryptable;
    }
}
</code></pre>
<p>添加一个AB分区的时候
未添加　slotselect 参数导致的无法挂载, Skipping</p>
<pre><code>[   23.075795] .(3)[273:wdtk-3][wdk-c] cpu=3,lbit=0x9,cbit=0xf,0,1,2930432545,[23075790516,19999990,43072185]
[   23.075804] .(3)[273:wdtk-3][thread:273][RT:23075799901] 2019-09-05 12:52:45.905161 UTC;android time 2019-09-05 12:52:45.905161
[   23.084361] .(2)[272:wdtk-2][wdk-c] cpu=2,lbit=0xd,cbit=0xf,0,1,2930432545,[23084350593,19991430,43072185]
[   23.140353] .(1)[271:wdtk-1][wdk-k] cpu=1,lbit=0xf,cbit=0xf,0,1,2930432545,[23140341209,19935439,43072185]
[   24.294772] .(1)[303:init]init: [libfs_mgr]Skipping '/dev/block/platform/bootdevice/by-name/secos' during mount_all
[   24.299752] .(2)[303:init]init: [libfs_mgr]superblock s_max_mnt_count:65535,/dev/block/platform/bootdevice/by-name/persist
[   24.301783] .(2)[303:init]EXT4-fs (mmcblk0p11): Ignoring removed nomblk_io_submit option
[   24.304515] .(2)[303:init]EXT4-fs (mmcblk0p11): mounted filesystem with ordered data mode. Opts: errors=remount-ro,nomblk_io_submit
[   24.306406] .(2)[303:init]init: [libfs_mgr]check_fs(): mount(/dev/block/platform/bootdevice/by-name/persist,/mnt/vendor/persist,ext4)=0: Success
[   24.309307] .(2)[303:init]init: [libfs_mgr]check_fs(): unmount(/mnt/vendor/persist) succeeded

</code></pre>
<p>开机只到bootlogo 阶段，　出现了 hwcomposer 错误， 导致无法开机， 这个是因为挂载参数的错误</p>
<pre><code>01-01 00:23:45.730   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #13 checkModemReady fail...
01-01 00:23:45.810   435   435 I ccci_mdinit: (1):check_nvram_ready(), property_get(&quot;vendor.service.nvram_init&quot;) = , read_nvram_ready_retry = 5
01-01 00:23:45.816   458   458 W stp_dump: fail to get Sdcard stat :No such file or directory, count: 2
01-01 00:23:45.830   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #14 checkModemReady fail...
01-01 00:23:45.927   379   472 D AudioCustParam: checkNvramReady(), property_get(&quot;vendor.service.nvram_init&quot;) = , read_nvram_ready_retry = 4
01-01 00:23:45.930   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #15 checkModemReady fail...
01-01 00:23:46.030   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #16 checkModemReady fail...
01-01 00:23:46.067   456   456 I ADB_SERVICES: service_to_fd shell,v2,TERM=xterm:export ANDROID_LOG_TAGS=&quot;''&quot;; exec logcat
01-01 00:23:46.099   456   456 I ADB_SERVICES: local_socket_flush_outgoing read_data=3958
01-01 00:23:46.130   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #17 checkModemReady fail...
01-01 00:23:46.138   359   408 D TeeRegistryUpdate: Wait a bit longer for registry to appear [vendor/mediatek/proprietary/trustzone/trustonic/source/external/mobicore/common/400b/Daemon/src/RegistryUpdate.cpp:89]
01-01 00:23:46.206   388   388 E hwcomposer: [HWC] Can't get PQ service tried(21) times  
01-01 00:23:46.231   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #18 checkModemReady fail...
01-01 00:23:46.307   388   388 E hwcomposer: [HWC] Can't get PQ service tried(22) times  
01-01 00:23:46.311   435   435 I ccci_mdinit: (1):check_nvram_ready(), property_get(&quot;vendor.service.nvram_init&quot;) = , read_nvram_ready_retry = 6
01-01 00:23:46.331   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #19 checkModemReady fail...
01-01 00:23:46.408   388   388 E hwcomposer: [HWC] Can't get PQ service tried(23) times  
01-01 00:23:46.427   379   472 D AudioCustParam: checkNvramReady(), property_get(&quot;vendor.service.nvram_init&quot;) = , read_nvram_ready_retry = 5
01-01 00:23:46.431   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #20 checkModemReady fail...
01-01 00:23:46.509   388   388 E hwcomposer: [HWC] Can't get PQ service tried(24) times  
01-01 00:23:46.531   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #21 checkModemReady fail...
01-01 00:23:46.599   417   417 I wmt_launcher: (persist.vendor.connsys.fwlog.status) is not supported
01-01 00:23:46.610   388   388 E hwcomposer: [HWC] Can't get PQ service tried(25) times  
01-01 00:23:46.631   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #22 checkModemReady fail...
01-01 00:23:46.711   388   388 E hwcomposer: [HWC] Can't get PQ service tried(26) times  
01-01 00:23:46.731   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #23 checkModemReady fail...
01-01 00:23:46.811   435   435 I ccci_mdinit: (1):check_nvram_ready(), property_get(&quot;vendor.service.nvram_init&quot;) = , read_nvram_ready_retry = 7
01-01 00:23:46.812   388   388 E hwcomposer: [HWC] Can't get PQ service tried(27) times  
01-01 00:23:46.831   379   496 W SpeechMessengerNormal: formatShareMemoryThread(), #24 checkModemReady fail...
01-01 00:23:46.913   388   388 E hwcomposer: [HWC] Can't get PQ service tried(28) times  


</code></pre>
<p>一般情况是这个是第四个或者第五个参数有问题。</p>
<pre><code>#define DEVPATH(_part) /dev/block/platform/BOOTDEV/by-name/_part
DEVPATH(secos)      /mnt/vendor/secos   __MTK_DATAIMG_FSTYPE   defaults   FSMGR_FLAG_SYSTEM
</code></pre>
<h4 id="无法挂载在根目录">无法挂载在根目录</h4>
<p>系统启动的时候，找不到/secos目录</p>
<pre><code>01-01 00:00:57.039   379  2678 D vold    : Starting trim of /mnt/vendor/protect_f
01-01 00:00:57.039   379  2678 W vold    : Failed to open /mnt/vendor/protect_f: Permission denied
01-01 00:00:57.039   379  2678 D vold    : Starting trim of /mnt/vendor/protect_s
01-01 00:00:57.039   379  2678 W vold    : Failed to open /mnt/vendor/protect_s: Permission denied
01-01 00:00:57.040   379  2678 D vold    : Starting trim of /mnt/vendor/nvdata
01-01 00:00:57.040   379  2678 W vold    : Failed to open /mnt/vendor/nvdata: Permission denied
01-01 00:00:57.040   379  2678 D vold    : Starting trim of /mnt/vendor/nvcfg
01-01 00:00:57.040   379  2678 W vold    : Failed to open /mnt/vendor/nvcfg: Permission denied
01-01 00:00:57.040   379  2678 D vold    : Starting trim of /secos
01-01 00:00:57.040   379  2678 W vold    : Failed to open /secos: No such file or directory
01-01 00:00:57.040   379  2678 D vold    : Starting trim of /mnt/vendor/persist
01-01 00:00:57.040   379  2678 W vold    : Failed to open /mnt/vendor/persist: Permission denied
01-01 00:00:57.045   429   553 D MDP     : DpAsyncBlitStream: rot(0) flip(0) padding(c)
</code></pre>
<p>这个是因为， 系统启动的时候并没有创建 /secos 目录， 无法打开根目录。
不知道为什么总是无法创建根目录下的secos目录。</p>
<h2 id="验证方案">验证方案</h2>
<p>系统中验证是否已经添加好一个分区， 这个分区是否挂载上，挂载参数是否正确的的验证方法.</p>
<p>可以通过查看以下路径, 知道是否建立分区.</p>
<pre><code>/dev/block/platform/bootdevice/by-name/

lrwxrwxrwx 1 root root   21 2019-09-06 10:52 boot_a -&gt; /dev/block/mmcblk0p23
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 boot_b -&gt; /dev/block/mmcblk0p36
lrwxrwxrwx 1 root root   20 2019-09-06 10:52 boot_para -&gt; /dev/block/mmcblk0p1
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 dtbo_a -&gt; /dev/block/mmcblk0p24
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 dtbo_b -&gt; /dev/block/mmcblk0p37
lrwxrwxrwx 1 root root   20 2019-09-06 10:52 expdb -&gt; /dev/block/mmcblk0p3
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 flashinfo -&gt; /dev/block/mmcblk0p44
lrwxrwxrwx 1 root root   20 2019-09-06 10:52 frp -&gt; /dev/block/mmcblk0p4
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 gz_a -&gt; /dev/block/mmcblk0p21
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 gz_b -&gt; /dev/block/mmcblk0p34
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 lk_a -&gt; /dev/block/mmcblk0p22
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 lk_b -&gt; /dev/block/mmcblk0p35
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 logo -&gt; /dev/block/mmcblk0p16
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 md1img_a -&gt; /dev/block/mmcblk0p17
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 md1img_b -&gt; /dev/block/mmcblk0p29
lrwxrwxrwx 1 root root   20 2019-09-06 10:52 metadata -&gt; /dev/block/mmcblk0p7
lrwxrwxrwx 1 root root   20 2019-09-06 10:52 nvcfg -&gt; /dev/block/mmcblk0p5
lrwxrwxrwx 1 root root   20 2019-09-06 10:52 nvdata -&gt; /dev/block/mmcblk0p6
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 nvram -&gt; /dev/block/mmcblk0p15
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 otp -&gt; /dev/block/mmcblk0p43
lrwxrwxrwx 1 root root   20 2019-09-06 10:52 para -&gt; /dev/block/mmcblk0p2
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 persist -&gt; /dev/block/mmcblk0p11
lrwxrwxrwx 1 root root   23 2019-09-06 10:52 preloader_a -&gt; /dev/block/mmcblk0boot0
lrwxrwxrwx 1 root root   23 2019-09-06 10:52 preloader_b -&gt; /dev/block/mmcblk0boot1
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 proinfo -&gt; /dev/block/mmcblk0p14
lrwxrwxrwx 1 root root   20 2019-09-06 10:52 protect1 -&gt; /dev/block/mmcblk0p8
lrwxrwxrwx 1 root root   20 2019-09-06 10:52 protect2 -&gt; /dev/block/mmcblk0p9
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 scp_a -&gt; /dev/block/mmcblk0p19
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 scp_b -&gt; /dev/block/mmcblk0p31
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 sec1 -&gt; /dev/block/mmcblk0p13
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 seccfg -&gt; /dev/block/mmcblk0p10
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 secos_a -&gt; /dev/block/mmcblk0p12 // 实际上的块设备, 这个块设备需要当做关键词在log中搜索
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 secos_b -&gt; /dev/block/mmcblk0p33 // 实际上的块设备
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 spmfw_a -&gt; /dev/block/mmcblk0p18
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 spmfw_b -&gt; /dev/block/mmcblk0p30
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 sspm_a -&gt; /dev/block/mmcblk0p20
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 sspm_b -&gt; /dev/block/mmcblk0p32
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 system_a -&gt; /dev/block/mmcblk0p27
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 system_b -&gt; /dev/block/mmcblk0p40
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 tee_a -&gt; /dev/block/mmcblk0p25
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 tee_b -&gt; /dev/block/mmcblk0p38
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 userdata -&gt; /dev/block/mmcblk0p42
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 vbmeta_a -&gt; /dev/block/mmcblk0p28
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 vbmeta_b -&gt; /dev/block/mmcblk0p41
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 vendor_a -&gt; /dev/block/mmcblk0p26
lrwxrwxrwx 1 root root   21 2019-09-06 10:52 vendor_b -&gt; /dev/block/mmcblk0p39

/vendor/etc/fstab.mt6761  // 挂载的fstab文件
/vendor/etc/fstab.mt8766  // 挂载的fstab文件
vendor/secos -&gt; /mnt/vendor/secos 
</code></pre>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://xuwanjin.me//post/the_processing_of_resolving_anr_of_calendar">
              <h3 class="post-title">
                记一次 Monkey Calendar  解决的过程
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="http://xuwanjin.me//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
