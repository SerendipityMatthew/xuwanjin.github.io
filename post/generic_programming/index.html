<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>泛型 / Generic programming | Gridea</title>
<link rel="shortcut icon" href="http://xuwanjin.me//favicon.ico?v=1568731218298">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://xuwanjin.me//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://xuwanjin.me/">
  <img class="avatar" src="http://xuwanjin.me//images/avatar.png?v=1568731218298" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              泛型 / Generic programming
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-09-17 ·
              </time>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('http://xuwanjin.me//post-images/generic_programming.png')">
              </div>
            
            <div class="post-content">
              <p>学习泛型</p>
<!-- more -->
<h1 id="泛型-generic-programming">泛型 / Generic programming</h1>
<p>@(Java)[java]</p>
<h2 id="常见用法">常见用法</h2>
<h3 id="泛型类">泛型类</h3>
<pre><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
// ArrayList 后面的&lt;E&gt; 在这里声明了, 整个类就可以使用了
// AbstractList 后面的就是使用前面的 E
</code></pre>
<pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
// &lt;K, V&gt; 就在这里声明了, 这样在整个类当中都可以使用这两个泛型了.
//AbstractMap 后面的	K, V
</code></pre>
<p>泛型的类型参数只能是类类型的, 不能是简单类型</p>
<h3 id="泛型方法">泛型方法</h3>
<p>一下是从 jdk8 的源码里找出来的一个典型的泛型方法</p>
<pre><code>// jdk/src/share/classes/java/util/Collections.java
// &lt;T&gt; 申明了泛型, 表示这是个泛型方法, 同时也申明了 T, 后面会用到
public static &lt;T&gt; void fill(List&lt;? super T&gt; list, T obj) {
    int size = list.size();

    if (size &lt; FILL_THRESHOLD || list instanceof RandomAccess) {
        for (int i=0; i&lt;size; i++)
            list.set(i, obj);
    } else {
        ListIterator&lt;? super T&gt; itr = list.listIterator();
        for (int i=0; i&lt;size; i++) {
            itr.next();
            itr.set(obj);
        }
    }
}
</code></pre>
<pre><code class="language-java">// RxJava/src/main/java/io/reactivex/Observable.java
// Obervable&lt;T&gt; 是返回的类型, 同时也声明了泛型 T;
// &lt;U, V&gt; 声明了 U, V 类型. 表明这个方法是泛型方法
public final &lt;U, V&gt; Observable&lt;T&gt; timeout(ObservableSource&lt;U&gt; firstTimeoutIndicator,
        Function&lt;? super T, ? extends ObservableSource&lt;V&gt;&gt; itemTimeoutIndicator) {
    ObjectHelper.requireNonNull(firstTimeoutIndicator, &quot;firstTimeoutIndicator is null&quot;);
    return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, null);
}

</code></pre>
<pre><code class="language-java">// dagger/internal/DoubleCheck.java
public static &lt;P extends Provider&lt;T&gt;, T&gt; Provider&lt;T&gt; provider(P delegate) {
  checkNotNull(delegate);
  if (delegate instanceof DoubleCheck) {
    /* This should be a rare case, but if we have a scoped @Binds that delegates to a scoped
     * binding, we shouldn't cache the value again. */
    return delegate;
  }
  return new DoubleCheck&lt;T&gt;(delegate);
}

</code></pre>
<h4 id="泛型方法出现在泛型类中">泛型方法出现在泛型类中</h4>
<h4 id="静态方法与泛型类">静态方法与泛型类</h4>
<h3 id="泛型接口">泛型接口</h3>
<pre><code class="language-java">public interface Iterable&lt;T&gt; {
    Iterator&lt;T&gt; iterator();
    default void forEach(Consumer&lt;? super T&gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
    default Spliterator&lt;T&gt; spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}

</code></pre>
<pre><code class="language-java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator&lt;E&gt; iterator();
    Object[] toArray();

    &lt;T&gt; T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection&lt;?&gt; c);
    boolean addAll(Collection&lt;? extends E&gt; c);
    boolean removeAll(Collection&lt;?&gt; c);
    default boolean removeIf(Predicate&lt;? super E&gt; filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator&lt;E&gt; each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
    boolean retainAll(Collection&lt;?&gt; c);
    void clear();
    boolean equals(Object o);
    int hashCode();
    @Override
    default Spliterator&lt;E&gt; spliterator() {
        return Spliterators.spliterator(this, 0);
    }
    default Stream&lt;E&gt; stream() {
        return StreamSupport.stream(spliterator(), false);
    }
    default Stream&lt;E&gt; parallelStream() {
        return StreamSupport.stream(spliterator(), true);
    }
}

</code></pre>
<h3 id="通配符">通配符</h3>
<pre><code class="language-java">public V computeIfPresent(K key,
                          BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
    if (remappingFunction == null)
        throw new NullPointerException();
    Node&lt;K,V&gt; e; V oldValue;
    int hash = hash(key);
    if ((e = getNode(hash, key)) != null &amp;&amp;
        (oldValue = e.value) != null) {
        V v = remappingFunction.apply(key, oldValue);
        if (v != null) {
            e.value = v;
            afterNodeAccess(e);
            return v;
        }
        else
            removeNode(hash, key, null, false, true);
    }
    return null;
}
</code></pre>
<h3 id="泛型上下边界">泛型上下边界</h3>
<p>有时候我们可以对传入的泛型类型实参进行限制. 可以指定是该类型的子类型. 比如这样 <code>&lt;T extends Number&gt;</code></p>
<pre><code class="language-java">import java.util.List;
// 在这里声明了 T这个泛型类型
public class Test&lt;T extends Number&gt; {
    public static void main(String[] args) {
    }
	// 使用? 通配符, 限定为 T 的子类型.
    public void sayHello(List&lt;? extends T&gt; t) {
    }
}
</code></pre>
<p>以下是设定泛型的为某个类的父类型</p>
<pre><code class="language-java">
public class Test06 {
    public static void main(String[] args) {
        Test06 test06 = new Test06();
        // 在这里传入一个 HashMap
        test06.sayHello(new ArrayList&lt;HashMap&lt;String, String&gt;&gt;());
    }
	// ? 限定为 LinkedHashMap 的父类型, 也就是 HashMap, AbstractMap 类型的
    public &lt;K, V&gt; void sayHello(ArrayList&lt;? super LinkedHashMap&lt;K, V&gt;&gt; t) {
        System.out.println(t);
    }
}
</code></pre>
<p>一下是在 HashMap 的源码里找到的一个方法.</p>
<pre><code class="language-java">@Override
public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
    Node&lt;K,V&gt;[] tab;
    if (function == null)
        throw new NullPointerException();
    if (size &gt; 0 &amp;&amp; (tab = table) != null) {
        int mc = modCount;
        for (int i = 0; i &lt; tab.length; ++i) {
            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                e.value = function.apply(e.key, e.value);
            }
        }
        if (modCount != mc)
            throw new ConcurrentModificationException();
    }
}

</code></pre>
<h3 id="泛型数组">泛型数组</h3>
<p>不能创建一个确切的泛型类型的数组.<br>
这个和素组的协变性有关系</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

public class Test&lt;T&gt; {
    public static void main(String[] args) {
	    // 这个会报 java: generic array creation 错误
        List&lt;Integer&gt;[] ls = new ArrayList&lt;Integer&gt;[10];
        // 下面的三个都不会报错
        List&lt;?&gt;[] ls1 = new ArrayList&lt;?&gt;[10];
        ArrayList&lt;String&gt;[] ls2 = new ArrayList[3];
        ArrayList&lt;String&gt;[] ls3 = (ArrayList&lt;String&gt;[]) new ArrayList[3];
    }
}
</code></pre>
<h2 id="泛型使用的注意点">泛型使用的注意点</h2>
<h3 id="不能运行时查询">不能运行时查询</h3>
<h3 id="异常时的泛型">异常时的泛型</h3>
<p>不能抛出也不能捕获泛型类的对象。<br>
不能再catch子句中使用泛型变量。</p>
<h3 id="没有泛型类数组">没有泛型类数组</h3>
<p>因为类型不安全</p>
<h3 id="泛型类中的静态方法和静态变量">泛型类中的静态方法和静态变量</h3>
<p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数<br>
在这里是不能使用泛型类所声明的泛型类型参数.</p>
<pre><code class="language-java">public class Test&lt;T&gt; {
    public T[] hello;
    //编译错误, 使用了泛型类的泛型参数
    public static T[] hell;

    public static void main(String[] args) {
    }

    //编译错误, 使用了泛型类的泛型参数
    public static T Hello(T e) {
        return e;
    }

    // 这个静态方法的泛型 T, 不再是泛型类的类型
    // 因为这个静态方法, 自己再次声明了一个同名的泛型
    public static &lt;T&gt; T Hello2(T e) {
        return e;
    }

    //没有错误, 没有使用泛型类的类型参数
    public static &lt;E&gt; E show(E one) {
        return one;
    }

    T show3(T one) {
        return one;
    }
}
</code></pre>
<h3 id="类型擦除后的冲突">类型擦除后的冲突</h3>
<h3 id="t-与-t-的区别"><T> 与 T 的区别</h3>
<p><T> 表示声明一个泛型, T 表示使用一个泛型</p>
<h3 id="t-与的区别"><T>  与&lt;?&gt;的区别</h3>
<p>public class Test extends ArrayList<E>   //这种写法是错误的</p>
<p>public class Test extends ArrayList</p>
<h3 id="原生态类型">原生态类型</h3>
<p>List 是原生态类型，原生态类型的存在是为了兼容　jdk 1.5之前的代码，　那时候还没有引入泛型<br>
在　类文字当中必须使用原生态类型<br>
List.class , String[].class, int.class. 但是　List&lt;String.class&gt; List&lt;?&gt;.class 都是不合法的</p>
<h3 id="arraylist-和-arraylistobject-区别">ArrayList 和 ArrayList&lt;Object&gt; 区别</h3>
<p>ArrayList 是原生态类型(raw type),就会失去类型安全性，但是如果时　ArrayList<Object>　　ArrayList<String>　这样的参数化类型就不会．</p>
<p>ArrayList<String>是原生态类型　ArrayList的子类型</p>
<pre><code class="language-java">ArrayList&lt;String&gt; stringArrayList = new ArrayList&lt;&gt;();
// if 里面的表达式永远为true
if (stringArrayList instanceof ArrayList){
    System.out.println(&quot;&quot;);
}
// 这个编译会出错，illegal genric type for instanceof
if (stringArrayList instanceof ArrayList&lt;String&gt;){
    System.out.println(&quot;&quot;);
}
// 可以使用通配符
if (stringArrayList instanceof ArrayList&lt;?&gt;){
    System.out.println(&quot;&quot;);
}
</code></pre>
<p>Set<Object> 是一个参数化类型, 表示可以包含任何类型对象的一个集合<br>
Set&lt;?&gt;则是一个通配符类型, 表示只能包含某种未知对象类性的一个集合<br>
Set 则是一个原生态类型，他脱离了泛型系统<br>
前两种时类型安全的，后面一种类型不安全的</p>
<p>Set&lt;?&gt; 和 Set 以及 Set<T> Set<String></p>
<p>public class Test<E> extends ArrayList</p>
<h3 id="数组和泛型">数组和泛型</h3>
<p>数组是协变的，　泛型类型时不可变的</p>
<pre><code class="language-java">public class Test{
    public static void main(String[] args) {
        Person[] person = new Person[3];
        Man[] man = new Man[3];
        if (man instanceof Person[]){
            
        }
    }
}
class Person{
}

class Man extends Person{
}
</code></pre>
<p>因为　Person 是　Man的子类型，　所以　Person[] 也是　Man[]的子类型<br>
所以，　man　instanceof Person[]为 true</p>
<p>数组时具体化的，　泛型时通过泛型擦除来实现的</p>
<pre><code>List&lt;Object&gt; objectList = new ArrayList&lt;Long&gt;();
</code></pre>
<pre><code class="language-java">// 假设如果第一步能通过的话
List&lt;String&gt;[] stringLists = new List&lt;String&gt;[1];
List&lt;Integer&gt; integerList = Arrays.asList(42);
// 数组的协变性, List&lt;String&gt; 是 object 类型的子类型, 可以赋值的
Object[] objects = stringLists;
// List&lt;Integer&gt; 根据类型擦除, 其实是 List 类型, integerList 运行时的类型是 List[]
objects[0] = integerList;
// stringLists[0] 得到的是 List&lt;String&gt; List, get 后会获取到 Integer 类型
String s = stringLists[0].get(0);

</code></pre>
<h3 id="uncheck-call">unCheck Call</h3>
<pre><code class="language-java">public class Test{
    public static void main(String[] args) {
        ArrayList arrayList = new ArrayList&lt;&gt;();
        arrayList.add(new Test());
        arrayList.add(&quot;Mathew&quot;);
        arrayList.add(1111);
        Object object = arrayList.get(1);
        String string = (String) arrayList.get(1);
        System.out.println(arrayList);
    }
}
</code></pre>
<h2 id="参考文献">参考文献</h2>
<ol>
<li><a href="https://my.oschina.net/goldenshaw/blog/895342"> 重复性管理——从泛值到泛型以及泛函（上）</a></li>
<li><a href="https://my.oschina.net/goldenshaw/blog/903273">重复性管理——从泛值到泛型以及泛函（中</a></li>
<li><a href="https://my.oschina.net/goldenshaw/blog/907019">重复性管理——从泛值到泛型以及泛函（下</a></li>
<li><a href="https://my.oschina.net/goldenshaw/blog/1529009">重复性管理——抽象的重要性（上</a></li>
<li><a href="https://my.oschina.net/goldenshaw/blog/1538309">重复性管理——抽象的重要性（下）</a></li>
<li><a href="https://en.wikipedia.org/wiki/Generic_programming">Generic programming in Wikipedia</a></li>
<li>[Effective Java]</li>
</ol>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://xuwanjin.me//post/learning_handler">
              <h3 class="post-title">
                Handler学习
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="http://xuwanjin.me//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
