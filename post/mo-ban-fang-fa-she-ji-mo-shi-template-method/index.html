<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>模板方法设计模式  Template Method | Gridea</title>
<link rel="shortcut icon" href="http://xuwanjin.me//favicon.ico?v=1564203759914">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://xuwanjin.me//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://xuwanjin.me/">
  <img class="avatar" src="http://xuwanjin.me//images/avatar.png?v=1564203759914" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              模板方法设计模式  Template Method
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-07-27 ·
              </time>
              
                <a href="http://xuwanjin.me//tag/DYemqMTK7" class="post-tag">
                  # 设计模式
                </a>
              
                <a href="http://xuwanjin.me//tag/Ar1WVhiiL" class="post-tag">
                  # 模板方法
                </a>
              
                <a href="http://xuwanjin.me//tag/MMp-M05aE" class="post-tag">
                  # Android
                </a>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('http://xuwanjin.me//post-images/mo-ban-fang-fa-she-ji-mo-shi-template-method.png')">
              </div>
            
            <div class="post-content">
              <p>个人对模板方法设计模式的的理解</p>
<!-- more -->
<h1 id="模板方法设计模式-template-method">模板方法设计模式  Template Method</h1>
<p>@(design pattern)
aosp</p>
<pre><code>AsyncTask
onPreExecute
doInBackground
onPostExecute
onProgressUpdate
</code></pre>
<pre><code class="language-java">public AsyncTask(@Nullable Looper callbackLooper) {
    mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()
        ? getMainHandler()
        : new Handler(callbackLooper);

    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
        public Result call() throws Exception {
            mTaskInvoked.set(true);
            Result result = null;
            try {
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                //noinspection unchecked
                result = doInBackground(mParams);
                Binder.flushPendingCommands();
            } catch (Throwable tr) {
                mCancelled.set(true);
                throw tr;
            } finally {
                postResult(result);
            }
            return result;
        }
    };

    mFuture = new FutureTask&lt;Result&gt;(mWorker) {
        @Override
        protected void done() {
            try {
                postResultIfNotInvoked(get());
            } catch (InterruptedException e) {
                android.util.Log.w(LOG_TAG, e);
            } catch (ExecutionException e) {
                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,
                        e.getCause());
            } catch (CancellationException e) {
                postResultIfNotInvoked(null);
            }
        }
    };
}
</code></pre>
<pre><code class="language-java">@MainThread
public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {
    // sDefaultExecutor   SerialExecutor 
    return executeOnExecutor(sDefaultExecutor, params);
}
</code></pre>
<pre><code class="language-java">@MainThread
public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
        Params... params) {
    // exec SerialExecutor

    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }

    mStatus = Status.RUNNING;
	// 空实现, 等待着子类的实现
    onPreExecute();

    mWorker.mParams = params;
    // exec 是 SerialExecutor 类型的
    // mFuture 是上面的构造函数的 FutureTask
    exec.execute(mFuture);

    return this;
}

</code></pre>
<pre><code class="language-java">
public synchronized void execute(final Runnable r) {
// r 就是上面的 mFuture, FutureTask 实现了 RunnableFuture, 而 RunnableFuture 继承了 Runnable
// mTasks 是ArrayDeque类型的, Offer 函数只是向里添加了一个 Runnable 类型的元素
    mTasks.offer(new Runnable() {
        public void run() {
            try {
                r.run();
            } finally {
                scheduleNext();
            }
        }
    });
// mActive 第一次进去是空的, 所以应该进入 if 语句
    if (mActive == null) {
        scheduleNext();
    }
}

</code></pre>
<pre><code class="language-java">
protected synchronized void scheduleNext() {
// mActive 从上面的mTasks 获取了一个 Runnable 类型的元素
    if ((mActive = mTasks.poll()) != null) {
    // THREAD_POOL_EXECUTOR 是一个 ThreadPoolExecutor 类型的变量, execute 方法只是执行
    // 该 mActive, 也就是运行 Runnable, 也就是 offer 函数里的 Runnable 被运行
        THREAD_POOL_EXECUTOR.execute(mActive);
    }
}

</code></pre>
<pre><code class="language-java">try {
// r 是 FutureTask 实例, FutureTask 的构造函数需要一个 Callable 类型的实例. 
// 也就是这里的 WorkerRunnable 类型的实例 mWorker
// 在 run 方法里调用 mWorker.call 方法
    r.run();  
} finally {
    scheduleNext();
}

</code></pre>
<pre><code class="language-java">public Result call() throws Exception {
    mTaskInvoked.set(true);
    Result result = null;
    try {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        //noinspection unchecked
		//  doInBackground 是一个抽象方法, 继承 AsyncTask 后自己实现, 返回 Result 的泛型
        result = doInBackground(mParams);
        Binder.flushPendingCommands();
    } catch (Throwable tr) {
        mCancelled.set(true);
        throw tr;
    } finally {
        postResult(result);
    }
    return result;
}

</code></pre>
<pre><code>@WorkerThread
protected abstract Result doInBackground(Params... params);
 // 空的方法, 子类继承 AysncTask 的时候, 实现方法,
 // 如果想要 UI 同步该操作的进度的, 需要自己调用 publishProgress 方法, 
</code></pre>
<pre><code class="language-java">@WorkerThread
protected final void publishProgress(Progress... values) {
    if (!isCancelled()) {
    // 在这这里发布 Handler 消息,
        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,
                new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();
    }
}
</code></pre>
<pre><code class="language-java">
public void handleMessage(Message msg) {
    AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
    switch (msg.what) {
        case MESSAGE_POST_RESULT:
            // There is only one result
            result.mTask.finish(result.mData[0]);
            break;
        case MESSAGE_POST_PROGRESS:
            result.mTask.onProgressUpdate(result.mData);
            break;
    }
}
</code></pre>
<pre><code class="language-java">@SuppressWarnings({&quot;UnusedDeclaration&quot;})
@MainThread
// 在这里更新 UI
protected void onProgressUpdate(Progress... values) {
}

</code></pre>
<pre><code class="language-java">// result 是 doInBackground 返回的结果, 发送 Handler 消息, 
// 将 AsyncTask 和 Result 一起封装形成 AsyncTaskResult, 发送出去
private Result postResult(Result result) {
    @SuppressWarnings(&quot;unchecked&quot;)
    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
            new AsyncTaskResult&lt;Result&gt;(this, result));
    message.sendToTarget();
    return result;
}

</code></pre>
<pre><code class="language-java">public void handleMessage(Message msg) {
    AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
    switch (msg.what) {
        case MESSAGE_POST_RESULT:
            // There is only one result
            result.mTask.finish(result.mData[0]);
            break;
        case MESSAGE_POST_PROGRESS:
            result.mTask.onProgressUpdate(result.mData);
            break;
    }
}

</code></pre>
<pre><code class="language-java">private void finish(Result result) {
// 判断是否取消
    if (isCancelled()) {
        onCancelled(result);
    } else {
    // onPostExecute 执行, 需要子类的实现
        onPostExecute(result);
    }
    mStatus = Status.FINISHED;
}

</code></pre>
<pre><code class="language-java">@SuppressWarnings({&quot;UnusedDeclaration&quot;})
@MainThread
protected void onPostExecute(Result result) {
// 空实现, 需要子类继承, 然后去实现这个方法.
}

</code></pre>
<p>至此 AysncTask 的几个方法 onPreExecute doInBackground onProgressUpdate onPostExecute 通过直接或者间接的方式, 形成了一个调用链. AsyncTask 把这四个函数的调用顺序固定好了. 子类只需要实现 AsyncTask 的空实现方法就行了</p>
<p>模板方法的设计模式, 在这个模式里, 抽象组件会实现该算法(AysncTask 的几个方法的调用顺序), 对算法的抽象部分剥离出来 (doInBackground, 抽象方法或者空实现),  然后具体的子组件会实现该抽象的部分</p>
<p>Activity 里 onCreate, onSaveInstanceState, onNewIntent,  onStart, onRestart,   onResume, onPause, onStop, onDestroy 他们的调用顺序在 Activity 类里已经明确规定好了, 子类继承了 Activity 之后, 可以 Override 相关的方法.</p>
<p>在这里 模板方法也是利用的 Java 的继承.</p>
<pre><code>Activity/Service/Provider

</code></pre>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://xuwanjin.me//post/ota-sheng-ji-ce-shi-de-yi-xie-cuo-wu">
              <h3 class="post-title">
                OTA 升级测试的一些错误
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="http://xuwanjin.me//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
